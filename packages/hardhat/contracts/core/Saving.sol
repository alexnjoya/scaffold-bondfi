// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";



// ["USDT", "WETH","AFR","AFX","cNGN","cGHS","cZAR","cKES"]
/* 
[
  "0x7dd1aD415F58D91BbF76BcC2640cc6FdD44Aa94b", 
  "0xaC56E37f70407f279e27cFcf2E31EdCa888EaEe4", 
  "0x48686EA995462d611F4DA0d65f90B21a30F259A5", 
  "0xC0c182d9895882C61C1fC1DF20F858e5E29a4f71", 
  "0xCcD4D22E24Ab5f9FD441a6E27bC583d241554a3c",
  "0x2Efddc5a4FEc6a4308c7206B0E0E9b3898520108", 
  "0x2B2068a831e7C7B2Ac4D97Cd293F934d2625aB69"  
]


*/

/**
 * @title AjoEsusuSavings
 * @dev Enhanced smart contract for traditional African savings groups (Ajo/Esusu) with DeFi integration
 * Supports multiple stablecoins including cNGN, cZAR, and AfriStable
 * Enhanced for frontend integration and demo purposes
 */
contract AjoEsusuSavings is ReentrancyGuard, Ownable, Pausable {
    
    struct SavingsGroup {
        uint256 groupId;
        string name;
        string description;
        address creator;
        string creatorName;
        IERC20 token; // The stablecoin used for this group
        uint256 contributionAmount; // Fixed amount each member contributes
        uint256 contributionFrequency; // In seconds (e.g., 60 for 1 minute, 86400 for daily)
        uint256 maxMembers;
        uint256 currentMembers;
        uint256 currentRound;
        uint256 totalRounds;
        uint256 startTime;
        uint256 lastContributionTime;
        uint256 nextContributionDeadline;
        bool isActive;
        bool isCompleted;
        address[] members;
        string[] memberNames;
        address[] payoutOrder; // Order in which members receive payouts
        mapping(address => bool) isMember;
        mapping(address => uint256) memberIndex;
        mapping(address => string) memberToName;
        mapping(uint256 => mapping(address => bool)) hasContributed; // round => member => contributed
        mapping(uint256 => mapping(address => uint256)) contributionTimestamp; // round => member => timestamp
        mapping(uint256 => address) roundRecipient; // round => recipient address
        mapping(uint256 => bool) roundCompleted;
        mapping(uint256 => uint256) roundStartTime; // round => start timestamp
    }
    struct AjoAgent {
        bool isActive;
        string name;
        string contactInfo; // Phone, email, etc.
        uint256 groupsCreated;
        uint256 successfulGroups;
        uint256 failedGroups;
        uint256 reputationScore; // 0-100 based on group success rate
        uint256 registrationDate;
        mapping(string => bool) usedCodes; // Track used invite codes
        string[] generatedCodes; // All codes generated by this agent
    }

    struct InviteCode {
    string code;
    address agent;
    uint256 groupId;
    bool isActive;
    uint256 maxUses;
    uint256 currentUses;
    uint256 expiryTime;
    address[] usedBy; // Track who used this code
    }

    struct MemberInfo {
        string name;
        uint256 totalContributions;
        uint256 totalReceived;
        uint256 activeGroups;
        uint256 completedGroups;
        bool hasRegistered;
        bool hasDefaulted;
        uint256 reputationScore; // 0-100, affects eligibility for groups
        uint256 joinDate;
        uint256 lastActivity;
    }

    struct GroupSummary {
        uint256 groupId;
        string name;
        address creator;
        string creatorName;
        address token;
        uint256 contributionAmount;
        uint256 currentMembers;
        uint256 maxMembers;
        uint256 currentRound;
        uint256 totalRounds;
        bool isActive;
        bool isCompleted;
        bool canJoin;
        uint256 nextContributionDeadline;
        address currentRecipient;
        string currentRecipientName;
    }

    struct ContributionStatus {
        bool hasContributed;
        uint256 contributionTime;
        bool isLate;
        uint256 timeRemaining;
    }

    // State variables
    uint256 public nextGroupId = 1;
    uint256 public platformFeePercentage = 50; // 0.5% (50/10000)
    uint256 public constant MIN_CONTRIBUTION_FREQUENCY = 60; // 1 minute for demo
    uint256 public constant GRACE_PERIOD = 300; // 5 minutes grace period for demo
    
    mapping(address => uint256) public collectedFees; // token => amount
    mapping(uint256 => SavingsGroup) public savingsGroups;
    mapping(address => MemberInfo) public memberInfo;
    mapping(address => uint256[]) public userGroups; // User's active group IDs
    mapping(address => uint256[]) public userCompletedGroups; // User's completed group IDs
    mapping(address => bool) public supportedTokens; // Supported stablecoins
    mapping(address => string) public tokenNames; // Token address to name mapping
    mapping(address => string) public userNames; // User address to name mapping
    address[] public supportedTokensList; // Array of supported token addresses
    mapping(address => AjoAgent) public ajoAgents;
    mapping(string => InviteCode) public inviteCodes; // code => InviteCode
    mapping(uint256 => string) public groupInviteCode; // groupId => invite code
    mapping(address => bool) public isAjoAgent;
    address[] public allAjoAgents;
    uint256 public agentRegistrationFee = 0; // Can be set by owner
    uint256 public minAgentReputation = 70; // Minimum reputation to remain active agent

    
    // Events
    event GroupCreated(uint256 indexed groupId, address indexed creator, string creatorName, string name, address token, uint256 contributionAmount);
    event MemberJoined(uint256 indexed groupId, address indexed member, string memberName);
    event ContributionMade(uint256 indexed groupId, address indexed member, string memberName, uint256 amount, uint256 round, uint256 timestamp);
    event PayoutDistributed(uint256 indexed groupId, address indexed recipient, string recipientName, uint256 amount, uint256 round);
    event GroupCompleted(uint256 indexed groupId, string name);
    event DefaultDetected(uint256 indexed groupId, address indexed defaulter, string defaulterName, uint256 round);
    event TokenSupported(address indexed token, string name, bool supported);
    event FeesWithdrawn(address indexed token, uint256 amount, address indexed owner);
    event UserRegistered(address indexed user, string name);
    event RoundStarted(uint256 indexed groupId, uint256 round, address recipient, string recipientName, uint256 deadline);
    event AjoAgentRegistered(address indexed agent, string name, string contactInfo);
    event AjoAgentDeactivated(address indexed agent, string reason);
    event InviteCodeGenerated(string indexed code, address indexed agent, uint256 indexed groupId, uint256 maxUses);
    event MemberJoinedWithCode(uint256 indexed groupId, address indexed member, string memberName, string inviteCode, address indexed agent);




    constructor(address[] memory _supportedTokens, string[] memory _tokenNames) Ownable(msg.sender) {
        require(_supportedTokens.length == _tokenNames.length, "Arrays length mismatch");
        
        // Initialize supported tokens
        for (uint256 i = 0; i < _supportedTokens.length; i++) {
            supportedTokens[_supportedTokens[i]] = true;
            tokenNames[_supportedTokens[i]] = _tokenNames[i];
            supportedTokensList.push(_supportedTokens[i]);
        }
    }

    // Modifiers
    modifier validGroupId(uint256 _groupId) {
        require(_groupId > 0 && _groupId < nextGroupId, "Invalid group ID");
        _;
    }

    modifier onlyGroupMember(uint256 _groupId) {
        require(savingsGroups[_groupId].isMember[msg.sender], "Not a group member");
        _;
    }

    modifier groupActive(uint256 _groupId) {
        require(savingsGroups[_groupId].isActive, "Group not active");
        _;
    }

    modifier registeredUser() {
        require(bytes(userNames[msg.sender]).length > 0, "User not registered");
        _;
    }

    modifier onlyActiveAjoAgent() {
    require(isAjoAgent[msg.sender] && ajoAgents[msg.sender].isActive, "Not an active Ajo agent");
    _;
}

    modifier validInviteCode(string memory _code) {
        require(bytes(_code).length > 0, "Invalid invite code");
        require(inviteCodes[_code].isActive, "Invite code not active");
        require(inviteCodes[_code].currentUses < inviteCodes[_code].maxUses, "Invite code exhausted");
        require(block.timestamp < inviteCodes[_code].expiryTime, "Invite code expired");
    _;
}


    // User registration
    function registerUser(string memory _name) external {
        require(bytes(_name).length > 0, "Name cannot be empty");
        require(bytes(_name).length <= 50, "Name too long");
       require(!memberInfo[msg.sender].hasRegistered, "Already Registered");
        
        userNames[msg.sender] = _name;
        
        if (memberInfo[msg.sender].joinDate == 0) {
            memberInfo[msg.sender].name = _name;
            memberInfo[msg.sender].reputationScore = 75; // Default reputation
            memberInfo[msg.sender].joinDate = block.timestamp;
             memberInfo[msg.sender].hasRegistered = true;
        }
        memberInfo[msg.sender].lastActivity = block.timestamp;
        
        emit UserRegistered(msg.sender, _name);
    }


/**
 * @dev Register as an Ajo Agent
 */
function registerAsAjoAgent(string memory _name, string memory _contactInfo) external payable registeredUser {
    require(!isAjoAgent[msg.sender], "Already an Ajo agent");
    require(msg.value >= agentRegistrationFee, "Insufficient registration fee");
    require(bytes(_name).length > 0 && bytes(_name).length <= 100, "Invalid name");
    require(bytes(_contactInfo).length > 0 && bytes(_contactInfo).length <= 200, "Invalid contact info");
    require(memberInfo[msg.sender].reputationScore >= minAgentReputation, "Insufficient reputation");

    ajoAgents[msg.sender].isActive = true;
    ajoAgents[msg.sender].name = _name;
    ajoAgents[msg.sender].contactInfo = _contactInfo;
    ajoAgents[msg.sender].reputationScore = memberInfo[msg.sender].reputationScore;
    ajoAgents[msg.sender].registrationDate = block.timestamp;

    isAjoAgent[msg.sender] = true;
    allAjoAgents.push(msg.sender);

    emit AjoAgentRegistered(msg.sender, _name, _contactInfo);
}

    // Admin functions
    function addSupportedToken(address _token, string memory _name) external onlyOwner {
        require(!supportedTokens[_token], "Token already supported");
        supportedTokens[_token] = true;
        tokenNames[_token] = _name;
        supportedTokensList.push(_token);
        emit TokenSupported(_token, _name, true);
    }

    function removeSupportedToken(address _token) external onlyOwner {
        require(supportedTokens[_token], "Token not supported");
        supportedTokens[_token] = false;
        
        // Remove from supportedTokensList
        for (uint256 i = 0; i < supportedTokensList.length; i++) {
            if (supportedTokensList[i] == _token) {
                supportedTokensList[i] = supportedTokensList[supportedTokensList.length - 1];
                supportedTokensList.pop();
                break;
            }
        }
        
        emit TokenSupported(_token, tokenNames[_token], false);
    }

    function setPlatformFee(uint256 _feePercentage) external onlyOwner {
        require(_feePercentage <= 1000, "Fee too high"); // Max 10%
        platformFeePercentage = _feePercentage;
    }

    function withdrawFees(address _token, uint256 _amount) external onlyOwner {
        require(_amount <= collectedFees[_token], "Insufficient fees collected");
        collectedFees[_token] -= _amount;
        require(IERC20(_token).transfer(owner(), _amount), "Withdrawal failed");
        emit FeesWithdrawn(_token, _amount, owner());
    }

    function withdrawAllFees(address _token) external onlyOwner {
        uint256 amount = collectedFees[_token];
        require(amount > 0, "No fees to withdraw");
        collectedFees[_token] = 0;
        require(IERC20(_token).transfer(owner(), amount), "Withdrawal failed");
        emit FeesWithdrawn(_token, amount, owner());
    }

    // Core functions
    function createGroup(
        string memory _name,
        string memory _description,
        address _token,
        uint256 _contributionAmount,
        uint256 _contributionFrequency,
        uint256 _maxMembers
    ) external whenNotPaused registeredUser onlyActiveAjoAgent returns (uint256) {
        require(supportedTokens[_token], "Token not supported");
        require(_contributionAmount > 0, "Invalid contribution amount");
        require(_contributionFrequency >= MIN_CONTRIBUTION_FREQUENCY, "Frequency too short");
        require(_maxMembers >= 2 && _maxMembers <= 20, "Invalid max members"); // Reduced for demo
        require(bytes(_name).length > 0 && bytes(_name).length <= 100, "Invalid name");
        require(bytes(_description).length <= 500, "Description too long");
        
        if (isAjoAgent[msg.sender]) {
            ajoAgents[msg.sender].groupsCreated++;
        }

        uint256 groupId = nextGroupId++;
        SavingsGroup storage group = savingsGroups[groupId];
        
        group.groupId = groupId;
        group.name = _name;
        group.description = _description;
        group.creator = msg.sender;
        group.creatorName = userNames[msg.sender];
        group.token = IERC20(_token);
        group.contributionAmount = _contributionAmount;
        group.contributionFrequency = _contributionFrequency;
        group.maxMembers = _maxMembers;
        group.totalRounds = _maxMembers;
        group.isActive = false;
        
        // Creator automatically joins
        _addMember(groupId, msg.sender, userNames[msg.sender]);
        
        emit GroupCreated(groupId, msg.sender, userNames[msg.sender], _name, _token, _contributionAmount);
        return groupId;
    }

   

    /**
 * @dev Join group with invite code
 */
function joinGroupWithCode(uint256 _groupId, string memory _inviteCode) 
    external 
    validGroupId(_groupId) 
    validInviteCode(_inviteCode) 
    whenNotPaused 
    registeredUser 
{
    SavingsGroup storage group = savingsGroups[_groupId];
    InviteCode storage codeInfo = inviteCodes[_inviteCode];
    
    require(codeInfo.groupId == _groupId, "Code not for this group");
    require(!group.isCompleted, "Group completed");
    require(!group.isMember[msg.sender], "Already a member");
    require(group.currentMembers < group.maxMembers, "Group full");
    require(memberInfo[msg.sender].reputationScore >= 50, "Insufficient reputation"); // Lower threshold for invited members
    
    // Check if user has existing relationship with this agent (optional additional check)
    address agent = codeInfo.agent;
    
    _addMember(_groupId, msg.sender, userNames[msg.sender]);
    
    // Update invite code usage
    codeInfo.currentUses++;
    codeInfo.usedBy.push(msg.sender);
    
    emit MemberJoinedWithCode(_groupId, msg.sender, userNames[msg.sender], _inviteCode, agent);
    
    // Start group if full
    if (group.currentMembers == group.maxMembers) {
        _startGroup(_groupId);
    }
}


    function contribute(uint256 _groupId) external validGroupId(_groupId) onlyGroupMember(_groupId) groupActive(_groupId) nonReentrant {
        SavingsGroup storage group = savingsGroups[_groupId];
        require(!group.hasContributed[group.currentRound][msg.sender], "Already contributed this round");
        
        bool isFirstRound = group.currentRound == 1;
        bool canContribute = isFirstRound || block.timestamp >= group.lastContributionTime + group.contributionFrequency;
        require(canContribute, "Too early for contribution");

        // Transfer contribution
        require(group.token.transferFrom(msg.sender, address(this), group.contributionAmount), "Transfer failed");
        
        group.hasContributed[group.currentRound][msg.sender] = true;
        group.contributionTimestamp[group.currentRound][msg.sender] = block.timestamp;
        memberInfo[msg.sender].totalContributions += group.contributionAmount;
        memberInfo[msg.sender].lastActivity = block.timestamp;
        
        emit ContributionMade(_groupId, msg.sender, userNames[msg.sender], group.contributionAmount, group.currentRound, block.timestamp);
        
        // Check if round is complete
        _checkRoundCompletion(_groupId);
    }

    function claimPayout(uint256 _groupId) external validGroupId(_groupId) onlyGroupMember(_groupId) nonReentrant {
        SavingsGroup storage group = savingsGroups[_groupId];
        require(group.roundRecipient[group.currentRound] == msg.sender, "Not your turn");
        require(!group.roundCompleted[group.currentRound], "Already claimed");
        require(_isRoundReadyForPayout(_groupId), "Round not ready for payout");

        uint256 totalAmount = group.contributionAmount * group.currentMembers;
        uint256 platformFee = (totalAmount * platformFeePercentage) / 10000;
        uint256 payoutAmount = totalAmount - platformFee;

        group.roundCompleted[group.currentRound] = true;
        memberInfo[msg.sender].totalReceived += payoutAmount;
        memberInfo[msg.sender].lastActivity = block.timestamp;

        // Transfer payout
        require(group.token.transfer(msg.sender, payoutAmount), "Payout failed");
        
        // Store platform fee
        if (platformFee > 0) {
            collectedFees[address(group.token)] += platformFee;
        }

        emit PayoutDistributed(_groupId, msg.sender, userNames[msg.sender], payoutAmount, group.currentRound);

        // Move to next round or complete group
        if (group.currentRound < group.totalRounds) {
            group.currentRound++;
            group.lastContributionTime = block.timestamp;
            group.nextContributionDeadline = block.timestamp + group.contributionFrequency + GRACE_PERIOD;
            group.roundStartTime[group.currentRound] = block.timestamp;
            
            emit RoundStarted(_groupId, group.currentRound, 
                group.roundRecipient[group.currentRound], 
                group.memberToName[group.roundRecipient[group.currentRound]], 
                group.nextContributionDeadline);
        } else {
            _completeGroup(_groupId);
        }
    }

    // Internal functions
    function _addMember(uint256 _groupId, address _member, string memory _memberName) internal {
        SavingsGroup storage group = savingsGroups[_groupId];
        
        group.members.push(_member);
        group.memberNames.push(_memberName);
        group.isMember[_member] = true;
        group.memberIndex[_member] = group.currentMembers;
        group.memberToName[_member] = _memberName;
        group.currentMembers++;
        
        userGroups[_member].push(_groupId);
        memberInfo[_member].activeGroups++;
        
        emit MemberJoined(_groupId, _member, _memberName);
    }

    function _startGroup(uint256 _groupId) internal {
        SavingsGroup storage group = savingsGroups[_groupId];
        
        // Shuffle payout order
        group.payoutOrder = group.members;
        _shuffleArray(group.payoutOrder);
        
        // Set recipients for each round
        for (uint256 i = 0; i < group.totalRounds; i++) {
            group.roundRecipient[i + 1] = group.payoutOrder[i];
        }
        
        group.isActive = true;
        group.currentRound = 1;
        group.startTime = block.timestamp;
        group.lastContributionTime = block.timestamp;
        group.nextContributionDeadline = block.timestamp + group.contributionFrequency + GRACE_PERIOD;
        group.roundStartTime[1] = block.timestamp;
        
        emit RoundStarted(_groupId, 1, 
            group.roundRecipient[1], 
            group.memberToName[group.roundRecipient[1]], 
            group.nextContributionDeadline);
    }

    function _checkRoundCompletion(uint256 _groupId) internal {
        SavingsGroup storage group = savingsGroups[_groupId];
        
        uint256 contributorCount = 0;
        for (uint256 i = 0; i < group.members.length; i++) {
            if (group.hasContributed[group.currentRound][group.members[i]]) {
                contributorCount++;
            }
        }
        
        // If not all contributed after deadline, mark defaulters
        if (contributorCount < group.currentMembers && 
            block.timestamp > group.nextContributionDeadline) {
            _handleDefaults(_groupId);
        }
    }

    function _handleDefaults(uint256 _groupId) internal {
        SavingsGroup storage group = savingsGroups[_groupId];
        
        for (uint256 i = 0; i < group.members.length; i++) {
            address member = group.members[i];
            if (!group.hasContributed[group.currentRound][member]) {
                memberInfo[member].hasDefaulted = true;
                memberInfo[member].reputationScore = memberInfo[member].reputationScore > 20 ? 
                    memberInfo[member].reputationScore - 20 : 0;
                emit DefaultDetected(_groupId, member, userNames[member], group.currentRound);
            }
        }
    }

    function _isRoundReadyForPayout(uint256 _groupId) internal view returns (bool) {
        SavingsGroup storage group = savingsGroups[_groupId];
        
        uint256 contributorCount = 0;
        for (uint256 i = 0; i < group.members.length; i++) {
            if (group.hasContributed[group.currentRound][group.members[i]]) {
                contributorCount++;
            }
        }
        
        return contributorCount == group.currentMembers;
    }

    function _completeGroup(uint256 _groupId) internal {
        SavingsGroup storage group = savingsGroups[_groupId];
        
        group.isActive = false;
        group.isCompleted = true;
        
        // Update member stats
        for (uint256 i = 0; i < group.members.length; i++) {
            address member = group.members[i];
            memberInfo[member].activeGroups--;
            memberInfo[member].completedGroups++;
            
            // Move group to completed list
            userCompletedGroups[member].push(_groupId);
            
            // Increase reputation for successful completion
            if (!memberInfo[member].hasDefaulted) {
                memberInfo[member].reputationScore = memberInfo[member].reputationScore < 90 ? 
                    memberInfo[member].reputationScore + 10 : 100;
            }
        }

        address creator = group.creator;
    if (isAjoAgent[creator]) {
        bool groupSuccessful = true;
        
        // Check if any member defaulted
        for (uint256 i = 0; i < group.members.length; i++) {
            if (memberInfo[group.members[i]].hasDefaulted) {
                groupSuccessful = false;
                break;
            }
        }
        
        if (groupSuccessful) {
            ajoAgents[creator].successfulGroups++;
            // Increase agent reputation
            if (ajoAgents[creator].reputationScore < 95) {
                ajoAgents[creator].reputationScore += 5;
            }
        } else {
            ajoAgents[creator].failedGroups++;
            // Decrease agent reputation
            if (ajoAgents[creator].reputationScore > 10) {
                ajoAgents[creator].reputationScore -= 10;
            }
            
            // Deactivate agent if reputation too low
            if (ajoAgents[creator].reputationScore < 30) {
                ajoAgents[creator].isActive = false;
                emit AjoAgentDeactivated(creator, "Low reputation due to failed groups");
            }
        }
        
        emit GroupCompleted(_groupId, group.name);
    }
    }
   function _shuffleArray(address[] storage array) internal {
    for (uint256 i = 0; i < array.length; i++) { // added parentheses around 'array'
        uint256 n = i + uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, i))) % (array.length - i);
        address temp = array[n];
        array[n] = array[i];
        array[i] = temp;
    }
}

    /**
 * @dev Generate invite code for a group (only by agent who created the group)
 */
function generateInviteCode(
    uint256 _groupId, 
    uint256 _maxUses, 
    uint256 _validityDays
) external validGroupId(_groupId) onlyActiveAjoAgent returns (string memory) {
    require(savingsGroups[_groupId].creator == msg.sender, "Not the group creator");
    require(!savingsGroups[_groupId].isActive, "Group already active");
    require(_maxUses > 0 && _maxUses <= 50, "Invalid max uses");
    require(_validityDays > 0 && _validityDays <= 30, "Invalid validity period");

    // Generate unique code
    string memory code = _generateUniqueCode(_groupId, msg.sender);
    
    inviteCodes[code] = InviteCode({
        code: code,
        agent: msg.sender,
        groupId: _groupId,
        isActive: true,
        maxUses: _maxUses,
        currentUses: 0,
        expiryTime: block.timestamp + (_validityDays * 1 days),
        usedBy: new address[](0)
    });

    groupInviteCode[_groupId] = code;
    ajoAgents[msg.sender].usedCodes[code] = true;
    ajoAgents[msg.sender].generatedCodes.push(code);

    emit InviteCodeGenerated(code, msg.sender, _groupId, _maxUses);
    return code;
}


    // Enhanced view functions for frontend
    function getGroupSummary(uint256 _groupId) external view validGroupId(_groupId) returns (GroupSummary memory) {
        SavingsGroup storage group = savingsGroups[_groupId];
        
        return GroupSummary({
            groupId: _groupId,
            name: group.name,
            creator: group.creator,
            creatorName: group.creatorName,
            token: address(group.token),
            contributionAmount: group.contributionAmount,
            currentMembers: group.currentMembers,
            maxMembers: group.maxMembers,
            currentRound: group.currentRound,
            totalRounds: group.totalRounds,
            isActive: group.isActive,
            isCompleted: group.isCompleted,
            canJoin: !group.isCompleted && group.currentMembers < group.maxMembers && !group.isActive,
            nextContributionDeadline: group.nextContributionDeadline,
            currentRecipient: group.isActive ? group.roundRecipient[group.currentRound] : address(0),
            currentRecipientName: group.isActive ? group.memberToName[group.roundRecipient[group.currentRound]] : ""
        });
    }

    function getGroupDetails(uint256 _groupId) external view validGroupId(_groupId) returns (
        string memory name,
        string memory description,
        address creator,
        string memory creatorName,
        address token,
        string memory tokenName,
        uint256 contributionAmount,
        uint256 contributionFrequency,
        uint256 currentMembers,
        uint256 maxMembers,
        uint256 currentRound,
        uint256 totalRounds,
        bool isActive,
        bool isCompleted,
        uint256 startTime,
        uint256 nextContributionDeadline
    ) {
        SavingsGroup storage group = savingsGroups[_groupId];
        return (
            group.name,
            group.description,
            group.creator,
            group.creatorName,
            address(group.token),
            tokenNames[address(group.token)],
            group.contributionAmount,
            group.contributionFrequency,
            group.currentMembers,
            group.maxMembers,
            group.currentRound,
            group.totalRounds,
            group.isActive,
            group.isCompleted,
            group.startTime,
            group.nextContributionDeadline
        );
    }

    function getGroupMembersWithNames(uint256 _groupId) external view validGroupId(_groupId) returns (address[] memory addresses, string[] memory names) {
        SavingsGroup storage group = savingsGroups[_groupId];
        return (group.members, group.memberNames);
    }

    function getPayoutOrder(uint256 _groupId) external view validGroupId(_groupId) returns (address[] memory addresses, string[] memory names) {
        SavingsGroup storage group = savingsGroups[_groupId];
        require(group.isActive || group.isCompleted, "Group not started");
        
        string[] memory payoutNames = new string[](group.payoutOrder.length);
        for (uint256 i = 0; i < group.payoutOrder.length; i++) {
            payoutNames[i] = group.memberToName[group.payoutOrder[i]];
        }
        
        return (group.payoutOrder, payoutNames);
    }

    function getUserContributionStatus(uint256 _groupId, address _user) external view validGroupId(_groupId) returns (ContributionStatus memory) {
        SavingsGroup storage group = savingsGroups[_groupId];
        
        bool hasContributed = group.hasContributed[group.currentRound][_user];
        uint256 contributionTime = group.contributionTimestamp[group.currentRound][_user];
        bool isLate = hasContributed && contributionTime > group.roundStartTime[group.currentRound] + group.contributionFrequency;
        uint256 timeRemaining = group.nextContributionDeadline > block.timestamp ? 
            group.nextContributionDeadline - block.timestamp : 0;
        
        return ContributionStatus({
            hasContributed: hasContributed,
            contributionTime: contributionTime,
            isLate: isLate,
            timeRemaining: timeRemaining
        });
    }

    function getAllActiveGroups() external view returns (GroupSummary[] memory) {
        uint256 activeCount = 0;
        
        // Count active groups
        for (uint256 i = 1; i < nextGroupId; i++) {
            if (savingsGroups[i].isActive && !savingsGroups[i].isCompleted) {
                activeCount++;
            }
        }
        
        GroupSummary[] memory activeGroups = new GroupSummary[](activeCount);
        uint256 index = 0;
        
        for (uint256 i = 1; i < nextGroupId; i++) {
            if (savingsGroups[i].isActive && !savingsGroups[i].isCompleted) {
                activeGroups[index] = this.getGroupSummary(i);
                index++;
            }
        }
        
        return activeGroups;
    }

    function getJoinableGroups() external view returns (GroupSummary[] memory) {
        uint256 joinableCount = 0;
        
        // Count joinable groups
        for (uint256 i = 1; i < nextGroupId; i++) {
            SavingsGroup storage group = savingsGroups[i];
            if (!group.isCompleted && group.currentMembers < group.maxMembers && !group.isActive) {
                joinableCount++;
            }
        }
        
        GroupSummary[] memory joinableGroups = new GroupSummary[](joinableCount);
        uint256 index = 0;
        
        for (uint256 i = 1; i < nextGroupId; i++) {
            SavingsGroup storage group = savingsGroups[i];
            if (!group.isCompleted && group.currentMembers < group.maxMembers && !group.isActive) {
                joinableGroups[index] = this.getGroupSummary(i);
                index++;
            }
        }
        
        return joinableGroups;
    }

    /**
 * @dev Deactivate invite code
 */
function deactivateInviteCode(string memory _code) external {
    InviteCode storage codeInfo = inviteCodes[_code];
    require(codeInfo.agent == msg.sender || msg.sender == owner(), "Not authorized");
    codeInfo.isActive = false;
}

/**
 * @dev Get agent information
 */
function getAjoAgentInfo(address _agent) external view returns (
    bool isActive,
    string memory name,
    string memory contactInfo,
    uint256 groupsCreated,
    uint256 successfulGroups,
    uint256 failedGroups,
    uint256 reputationScore,
    uint256 registrationDate
) {
    AjoAgent storage agent = ajoAgents[_agent];
    return (
        agent.isActive,
        agent.name,
        agent.contactInfo,
        agent.groupsCreated,
        agent.successfulGroups,
        agent.failedGroups,
        agent.reputationScore,
        agent.registrationDate
    );
}

/**
 * @dev Get invite code information
 */
function getInviteCodeInfo(string memory _code) external view returns (
    address agent,
    string memory agentName,
    uint256 groupId,
    string memory groupName,
    bool isActive,
    uint256 maxUses,
    uint256 currentUses,
    uint256 expiryTime
) {
    InviteCode storage codeInfo = inviteCodes[_code];
    return (
        codeInfo.agent,
        ajoAgents[codeInfo.agent].name,
        codeInfo.groupId,
        savingsGroups[codeInfo.groupId].name,
        codeInfo.isActive,
        codeInfo.maxUses,
        codeInfo.currentUses,
        codeInfo.expiryTime
    );
}

/**
 * @dev Generate unique invite code
 */
function _generateUniqueCode(uint256 _groupId, address _agent) internal view returns (string memory) {
    return string(abi.encodePacked(
        "AJO",
        _toString(_groupId),
        _toString(uint256(uint160(_agent)) % 10000),
        _toString(block.timestamp % 10000)
    ));
}

/**
 * @dev Convert uint to string
 */
function _toString(uint256 value) internal pure returns (string memory) {
    if (value == 0) return "0";
    
    uint256 temp = value;
    uint256 digits;
    while (temp != 0) {
        digits++;
        temp /= 10;
    }
    
    bytes memory buffer = new bytes(digits);
    while (value != 0) {
        digits -= 1;
        buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
        value /= 10;
    }
    
    return string(buffer);
}

   function setAgentRegistrationFee(uint256 _fee) external onlyOwner {
    agentRegistrationFee = _fee;
}

function setMinAgentReputation(uint256 _minReputation) external onlyOwner {
    require(_minReputation <= 100, "Invalid reputation");
    minAgentReputation = _minReputation;
}

function deactivateAgent(address _agent, string memory _reason) external onlyOwner {
    require(isAjoAgent[_agent], "Not an agent");
    ajoAgents[_agent].isActive = false;
    emit AjoAgentDeactivated(_agent, _reason);
}

function getAllActiveAgents() external view returns (address[] memory) {
    uint256 activeCount = 0;
    for (uint256 i = 0; i < allAjoAgents.length; i++) {
        if (ajoAgents[allAjoAgents[i]].isActive) {
            activeCount++;
        }
    }
    
    address[] memory activeAgents = new address[](activeCount);
    uint256 index = 0;
    for (uint256 i = 0; i < allAjoAgents.length; i++) {
        if (ajoAgents[allAjoAgents[i]].isActive) {
            activeAgents[index] = allAjoAgents[i];
            index++;
        }
    }
    
    return activeAgents;
}

    function getUserGroups(address _user) external view returns (uint256[] memory) {
        return userGroups[_user];
    }

    function getUserCompletedGroups(address _user) external view returns (uint256[] memory) {
        return userCompletedGroups[_user];
    }

    function getMemberInfo(address _member) external view returns (MemberInfo memory) {
        return memberInfo[_member];
    }

    function getCurrentRecipient(uint256 _groupId) external view validGroupId(_groupId) returns (address recipient, string memory name) {
        SavingsGroup storage group = savingsGroups[_groupId];
        address addr = group.roundRecipient[group.currentRound];
        return (addr, group.memberToName[addr]);
    }

    function getSupportedTokens() external view returns (address[] memory addresses, string[] memory names) {
        string[] memory tokenNamesList = new string[](supportedTokensList.length);
        for (uint256 i = 0; i < supportedTokensList.length; i++) {
            tokenNamesList[i] = tokenNames[supportedTokensList[i]];
        }
        return (supportedTokensList, tokenNamesList);
    }

    function getUserName(address _user) external view returns (string memory) {
        return userNames[_user];
    }

    function isUserRegistered(address _user) external view returns (bool) {
        return bytes(userNames[_user]).length > 0;
    }

    function getAccumulatedFees(address _token) external view returns (uint256) {
        return collectedFees[_token];
    }

    function getTotalStats() external view returns (
        uint256 totalGroups,
        uint256 activeGroups,
        uint256 completedGroups,
        uint256 totalUsers
    ) {
        uint256 active = 0;
        uint256 completed = 0;
        
        for (uint256 i = 1; i < nextGroupId; i++) {
            if (savingsGroups[i].isActive) active++;
            if (savingsGroups[i].isCompleted) completed++;
        }
        
        return (nextGroupId - 1, active, completed, 0); // totalUsers would need separate tracking
    }

    // Emergency functions
    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    function emergencyWithdraw(uint256 _groupId, address _token) external onlyOwner {
        require(!savingsGroups[_groupId].isActive, "Group still active");
        IERC20(_token).transfer(owner(), IERC20(_token).balanceOf(address(this)));
    }
}